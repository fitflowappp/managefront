{"version":3,"sources":["../../../src/components/draft/getTextContentFromFiles.js"],"names":["TEXT_CLIPPING_REGEX","TEXT_TYPES","TEXT_SIZE_UPPER_BOUND","getTextContentFromFiles","files","callback","readCount","results","forEach","file","readFile","text","push","slice","length","join","global","FileReader","type","contents","test","name","replace","reader","onload","result","onerror","readAsText","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAYA;;AAEA,IAAIA,sBAAsB,iBAA1B;;AAEA,IAAIC,aAAa;AACf,gBAAc,IADC;AAEf,eAAa,IAFE;AAGf,cAAY;AAHG,CAAjB;;AAMA;AACA,IAAIC,wBAAwB,IAA5B;;AAEA;;;AAGA,SAASC,uBAAT,CAAiCC,KAAjC,EAAwCC,QAAxC,EAAkD;AAChD,MAAIC,YAAY,CAAhB;AACA,MAAIC,UAAU,EAAd;AACAH,QAAMI,OAAN,CAAc,WAAW,QAAQC,IAAnB,EAAyB;AACrCC,aAASD,IAAT,EAAe,WAAW,UAAUE,IAArB,EAA2B;AACxCL;AACAK,cAAQJ,QAAQK,IAAR,CAAaD,KAAKE,KAAL,CAAW,CAAX,EAAcX,qBAAd,CAAb,CAAR;AACA,UAAII,aAAaF,MAAMU,MAAvB,EAA+B;AAC7BT,iBAASE,QAAQQ,IAAR,CAAa,IAAb,CAAT;AACD;AACF,KAND;AAOD,GARD;AASD;;AAED;;;AAGA,SAASL,QAAT,CAAkBD,IAAlB,EAAwBJ,QAAxB,EAAkC;AAChC,MAAI,CAACW,OAAOC,UAAR,IAAsBR,KAAKS,IAAL,IAAa,EAAET,KAAKS,IAAL,IAAajB,UAAf,CAAvC,EAAmE;AACjEI,aAAS,EAAT;AACA;AACD;;AAED,MAAII,KAAKS,IAAL,KAAc,EAAlB,EAAsB;AACpB,QAAIC,WAAW,EAAf;AACA;AACA;AACA;AACA;AACA,QAAInB,oBAAoBoB,IAApB,CAAyBX,KAAKY,IAA9B,CAAJ,EAAyC;AACvCF,iBAAWV,KAAKY,IAAL,CAAUC,OAAV,CAAkBtB,mBAAlB,EAAuC,EAAvC,CAAX;AACD;AACDK,aAASc,QAAT;AACA;AACD;;AAED,MAAII,SAAS,IAAIN,UAAJ,EAAb;AACAM,SAAOC,MAAP,GAAgB,YAAY;AAC1BnB,aAASkB,OAAOE,MAAhB;AACD,GAFD;AAGAF,SAAOG,OAAP,GAAiB,YAAY;AAC3BrB,aAAS,EAAT;AACD,GAFD;AAGAkB,SAAOI,UAAP,CAAkBlB,IAAlB;AACD;;AAEDmB,OAAOC,OAAP,GAAiB1B,uBAAjB","file":"getTextContentFromFiles.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentFromFiles\n * \n */\n\n'use strict';\n\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\n\nvar TEXT_TYPES = {\n  'text/plain': true,\n  'text/html': true,\n  'text/rtf': true\n};\n\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\nvar TEXT_SIZE_UPPER_BOUND = 5000;\n\n/**\n * Extract the text content from a file list.\n */\nfunction getTextContentFromFiles(files, callback) {\n  var readCount = 0;\n  var results = [];\n  files.forEach(function ( /*blob*/file) {\n    readFile(file, function ( /*string*/text) {\n      readCount++;\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\n      if (readCount == files.length) {\n        callback(results.join('\\r'));\n      }\n    });\n  });\n}\n\n/**\n * todo isaac: Do work to turn html/rtf into a content fragment.\n */\nfunction readFile(file, callback) {\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\n    callback('');\n    return;\n  }\n\n  if (file.type === '') {\n    var contents = '';\n    // Special-case text clippings, which have an empty type but include\n    // `.textClipping` in the file name. `readAsText` results in an empty\n    // string for text clippings, so we force the file name to serve\n    // as the text value for the file.\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\n    }\n    callback(contents);\n    return;\n  }\n\n  var reader = new FileReader();\n  reader.onload = function () {\n    callback(reader.result);\n  };\n  reader.onerror = function () {\n    callback('');\n  };\n  reader.readAsText(file);\n}\n\nmodule.exports = getTextContentFromFiles;"]}