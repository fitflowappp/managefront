{"version":3,"sources":["../../../src/components/draft/editOnInput.js"],"names":["DraftModifier","require","DraftOffsetKey","EditorState","Entity","UserAgent","findAncestorOffsetKey","nullthrows","isGecko","isEngine","DOUBLE_NEWLINE","editOnInput","domSelection","global","getSelection","anchorNode","isCollapsed","nodeType","Node","TEXT_NODE","domText","textContent","editorState","props","offsetKey","_DraftOffsetKey$decode","decode","blockKey","decoratorKey","leafKey","_editorState$getBlockTree$getIn","getBlockTree","getIn","start","end","content","getCurrentContent","block","getBlockForKey","modelText","getText","slice","endsWith","selection","targetRange","merge","anchorOffset","focusOffset","isBackward","entityKey","getEntityAt","entity","get","entityType","getMutability","preserveEntity","changeType","newContent","replaceText","getInlineStyleAt","startOffset","endOffset","Math","min","abs","charDelta","length","getStartOffset","getEndOffset","contentWithAdjustedDOMSelection","selectionBefore","getSelectionAfter","selectionAfter","update","push","module","exports"],"mappings":"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","file":"editOnInput.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule editOnInput\n * \n */\n\n'use strict';\n\nvar DraftModifier = require('./DraftModifier');\nvar DraftOffsetKey = require('./DraftOffsetKey');\nvar EditorState = require('./EditorState');\nvar Entity = require('./DraftEntity');\nvar UserAgent = require('fbjs/lib/UserAgent');\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\nvar isGecko = UserAgent.isEngine('Gecko');\n\nvar DOUBLE_NEWLINE = '\\n\\n';\n\n/**\n * This function is intended to handle spellcheck and autocorrect changes,\n * which occur in the DOM natively without any opportunity to observe or\n * interpret the changes before they occur.\n *\n * The `input` event fires in contentEditable elements reliably for non-IE\n * browsers, immediately after changes occur to the editor DOM. Since our other\n * handlers override or otherwise handle cover other varieties of text input,\n * the DOM state should match the model in all controlled input cases. Thus,\n * when an `input` change leads to a DOM/model mismatch, the change should be\n * due to a spellcheck change, and we can incorporate it into our model.\n */\nfunction editOnInput() {\n  var domSelection = global.getSelection();\n\n  var anchorNode = domSelection.anchorNode;\n  var isCollapsed = domSelection.isCollapsed;\n\n  if (anchorNode.nodeType !== Node.TEXT_NODE) {\n    return;\n  }\n\n  var domText = anchorNode.textContent;\n  var editorState = this.props.editorState;\n\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\n\n  var _DraftOffsetKey$decode = DraftOffsetKey.decode(offsetKey);\n\n  var blockKey = _DraftOffsetKey$decode.blockKey;\n  var decoratorKey = _DraftOffsetKey$decode.decoratorKey;\n  var leafKey = _DraftOffsetKey$decode.leafKey;\n\n  var _editorState$getBlockTree$getIn = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]);\n\n  var start = _editorState$getBlockTree$getIn.start;\n  var end = _editorState$getBlockTree$getIn.end;\n\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(blockKey);\n  var modelText = block.getText().slice(start, end);\n\n  // Special-case soft newlines here. If the DOM text ends in a soft newline,\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\n  // We want to remove this extra newline for the purpose of our comparison\n  // of DOM and model text.\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\n    domText = domText.slice(0, -1);\n  }\n\n  // No change -- the DOM is up to date. Nothing to do here.\n  if (domText === modelText) {\n    return;\n  }\n\n  var selection = editorState.getSelection();\n\n  // We'll replace the entire leaf with the text content of the target.\n  var targetRange = selection.merge({\n    anchorOffset: start,\n    focusOffset: end,\n    isBackward: false\n  });\n\n  var entityKey = block.getEntityAt(start);\n  var entity = entityKey && Entity.get(entityKey);\n  var entityType = entity && entity.getMutability();\n  var preserveEntity = entityType === 'MUTABLE';\n\n  // Immutable or segmented entities cannot properly be handled by the\n  // default browser undo, so we have to use a different change type to\n  // force using our internal undo method instead of falling through to the\n  // native browser undo.\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\n\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\n\n  var anchorOffset, focusOffset, startOffset, endOffset;\n\n  if (isGecko) {\n    // Firefox selection does not change while the context menu is open, so\n    // we preserve the anchor and focus values of the DOM selection.\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    startOffset = start + Math.min(anchorOffset, focusOffset);\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\n    anchorOffset = startOffset;\n    focusOffset = endOffset;\n  } else {\n    // Browsers other than Firefox may adjust DOM selection while the context\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\n    // and adjust it based on the number of characters changed during the\n    // mutation.\n    var charDelta = domText.length - modelText.length;\n    startOffset = selection.getStartOffset();\n    endOffset = selection.getEndOffset();\n\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\n    focusOffset = endOffset + charDelta;\n  }\n\n  // Segmented entities are completely or partially removed when their\n  // text content changes. For this case we do not want any text to be selected\n  // after the change, so we are not merging the selection.\n  var contentWithAdjustedDOMSelection = newContent.merge({\n    selectionBefore: content.getSelectionAfter(),\n    selectionAfter: selection.merge({ anchorOffset: anchorOffset, focusOffset: focusOffset })\n  });\n\n  this.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\n}\n\nmodule.exports = editOnInput;"]}