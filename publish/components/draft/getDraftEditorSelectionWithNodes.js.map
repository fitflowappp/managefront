{"version":3,"sources":["../../../src/components/draft/getDraftEditorSelectionWithNodes.js"],"names":["findAncestorOffsetKey","require","getSelectionOffsetKeyForNode","getUpdatedSelectionState","invariant","nullthrows","getDraftEditorSelectionWithNodes","editorState","root","anchorNode","anchorOffset","focusNode","focusOffset","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","selectionState","needsRecovery","anchorPoint","focusPoint","key","offset","getPointForNonTextNode","firstChild","nodeName","getFirstLeaf","node","getLastLeaf","lastChild","editorRoot","childOffset","offsetKey","process","env","NODE_ENV","undefined","Element","getAttribute","childNodes","length","firstLeaf","nodeBeforeCursor","leafKey","textLength","getTextContentLength","lastLeaf","textContent","module","exports"],"mappings":"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","file":"getDraftEditorSelectionWithNodes.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @typechecks\n * \n */\n\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\n\n  // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true;\n\n  // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n\n    // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n\n/**\n * Identify the first leaf descendant for the given node.\n */\nfunction getFirstLeaf(node) {\n  while (node.firstChild && getSelectionOffsetKeyForNode(node.firstChild)) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Identify the last leaf descendant for the given node.\n */\nfunction getLastLeaf(node) {\n  while (node.lastChild && getSelectionOffsetKeyForNode(node.lastChild)) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, node, childOffset) {\n  var offsetKey = findAncestorOffsetKey(node);\n\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : undefined;\n\n  // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : undefined;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  }\n\n  // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return { key: key, offset: 0 };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;"]}